name: Release binaries

on:
  schedule:
  - cron: '00 10 * * *'
  push:
    branches:
    - 'workflow-test'

concurrency:
  group: release-binaries-${{ github.ref }}
  cancel-in-progress: true

permissions:
  actions: read
  attestations: write
  checks: read
  contents: write
  deployments: read
  id-token: write
  issues: read
  discussions: read
  packages: write
  pages: read
  pull-requests: read
  repository-projects: read
  security-events: read
  statuses: read

env:
  GHCR_REPO: "ghcr.io/anapsix/oq"
  REPO: ${{ github.repository }}
  UPSTREAM_REPO: Blacksmoke16/oq
  UPSTREAM_DIR: ./upstream
  TARGET_ARCH_LIST: '["arm64","amd64"]'

jobs:
  release_info:
    runs-on: ubuntu-latest
    outputs:
      release_tag: ${{ steps.info.outputs.release_tag }}
      create_release: ${{ steps.info.outputs.create_release }}
      push_to_ghcr: ${{ steps.check_ghcr.outputs.push_to_ghcr }}
    steps:
    - name: Prepare release info
      id: info
      uses: actions/github-script@v7
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        script: |
          const {REPO, UPSTREAM_REPO} = process.env;
          const [owner, repo] = REPO.split("/");
          const [uowner, urepo] = UPSTREAM_REPO.split("/");

          core.startGroup(`Getting release info for '${UPSTREAM_REPO}'`);
          const ulatest_release = await github.rest.repos.getLatestRelease({
            owner: uowner,
            repo: urepo,
          });

          core.debug(`Upsteam latests release data:\n${JSON.stringify(ulatest_release)}`);
          const ulatest_release_tag = ulatest_release.data.tag_name;
          core.info(`Latest release in '${UPSTREAM_REPO}' is '${ulatest_release_tag}'`);
          if (ulatest_release_tag.status != 200 && typeof(ulatest_release_tag) == 'undefined') {
            core.setFailed(`Failed to get release tag for '${UPSTREAM_REPO}'`);
          }
          core.endGroup();

          var matching_release = undefined;
          var create_release = true;
          core.startGroup(`Getting matching release in '${REPO}'`);
          try {
            matching_release = await github.rest.repos.getReleaseByTag({
              owner: owner,
              repo: repo,
              tag: ulatest_release_tag,
            });
          } catch (e) {
            core.info(`The matching release is not found for '${ulatest_release_tag}' tag`);
            if (e.name != 'HttpError') {
              core.setFailed(`Failed to get matching release, with error ${e}`);
            }
          }
          core.debug(`Matching release data:\n${JSON.stringify(matching_release)}`);
          if (typeof(matching_release) != 'undefined' && matching_release.status == 200) {
            create_release = false;
          }
          core.endGroup();

          core.warning(`release_tag: ${ulatest_release_tag}`);
          core.warning(`create_release: ${create_release}`);
          core.setOutput('release_tag', ulatest_release_tag);
          core.setOutput('create_release', create_release);
    - name: Login to GHCR
      uses: docker/login-action@v3
      with:
        registry: ghcr.io
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}
    - name: Check GHCR
      id: check_ghcr
      env:
        RELEASE_TAG: ${{ steps.info.outputs.release_tag }}
      run: |
        if docker manifest inspect "${GHCR_REPO}:${RELEASE_TAG}" >/dev/null; then
          echo "push_to_ghcr=false" | tee -a "${GITHUB_OUTPUT}"
        else
          echo "push_to_ghcr=true" | tee -a "${GITHUB_OUTPUT}"
        fi
  dist_linux:
    runs-on: ubuntu-latest
    needs: release_info
    if: ${{ needs.release_info.outputs.create_release == 'true' || needs.release_info.outputs.push_to_ghcr == 'true' }}
    steps:
    - name: Checkout hack
      uses: actions/checkout@v4
    - name: Checkout oq
      uses: actions/checkout@v4
      with:
        repository: Blacksmoke16/oq
        path: ${{ env.UPSTREAM_DIR }}
        fetch-tags: true
    - name: Set up QEMU
      uses: docker/setup-qemu-action@v3
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
    - name: Build
      run: ./hack/dist/build.sh
    - name: Login to GitHub Container Registry
      uses: docker/login-action@v3
      if: ${{ needs.release_info.outputs.push_to_ghcr == 'true' }}
      with:
        registry: ghcr.io
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}
    - name: Push to GHCR
      id: push_to_ghcr
      if: ${{ needs.release_info.outputs.push_to_ghcr == 'true' }}
      env:
        RELEASE_TAG: ${{ needs.release_info.outputs.release_tag }}
      run: |
        export TARGET_ARCH_LIST=( $(jq -r .[] <<< ${TARGET_ARCH_LIST}) )
        declare -a MANIFEST_LIST
        for arch in ${TARGET_ARCH_LIST[@]}; do
          echo "::group::pushing linux/${arch}"
          arch_uri="${GHCR_REPO}:${RELEASE_TAG}-${arch}"
          docker tag "oq:${arch}" "${arch_uri}"
          docker push "${arch_uri}"
          echo "::info::pushed ${arch_uri}"
          echo "::endgroup::"
          MANIFEST_LIST+=(${arch_uri})
        done
        echo "::group::pushing manifest"
        docker manifest create "${GHCR_REPO}:${RELEASE_TAG}" ${MANIFEST_LIST[@]}
        docker manifest push "${GHCR_REPO}:${RELEASE_TAG}"
        echo "::info::pushed ${GHCR_REPO}:${RELEASE_TAG}"
        echo "::endgroup::"
        echo "::group::recording manifest digest"
        MANIFEST_DIGEST="$(docker buildx imagetools \
          inspect "${GHCR_REPO}:${RELEASE_TAG}" --format '{{json .}}' \
          | jq -r .manifest.digest)"
        echo "manifest_digest=${MANIFEST_DIGEST}" | tee -a "${GITHUB_OUTPUT}"
        echo "::endgroup::"
    - name: Generate artifact attestation
      uses: actions/attest-build-provenance@v1
      if: ${{ needs.release_info.outputs.push_to_ghcr == 'true' }}
      with:
        subject-name: ${{ env.GHCR_REPO }}
        subject-digest: ${{ steps.push_to_ghcr.outputs.manifest_digest }}
        push-to-registry: true
    - name: Upload release artifacts
      uses: softprops/action-gh-release@v2
      if: ${{ needs.release_info.outputs.create_release == 'true' }}
      with:
        files: ./bin/oq-*
        tag_name: ${{ needs.release_info.outputs.release_tag }}
        make_latest: "true"
        body: |
          Corresponds to [${{ needs.release_info.outputs.release_tag }}][1] release in [Blacksmoke16/oq][2].

          [1]: https://github.com/Blacksmoke16/oq/releases/tag/${{ needs.release_info.outputs.release_tag }}
          [2]: https://github.com/Blacksmoke16/oq
